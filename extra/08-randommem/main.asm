    processor 6502

    include "../../incl/vcs.h"
    include "../../incl/macro.h"

    seg.u Variables
    org $80
Random byte            ; declare Random
Rand1  byte            ; declare Rand1
Rand2  byte            ; declare Rand2
Rand3  byte            ; declare Rand3
Rand4  byte            ; declare Rand4

    seg code
    org $F000          ; define the ROM code origin at $F000

Start:
    CLEAN_START        ; call macro to clear RAM and registers
    sei                ; disable interrupts
    cld                ; disable the BCD decimal math mode
    ldx #$FF           ; loads the X register with value #$FF
    txs                ; transfer X register to S(tack) Pointer

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Initialize variables
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    lda #%11010100
    sta Random         ; Random = $D4

    lda #$D4
    sta Rand1
    sta Rand2
    sta Rand3
    sta Rand4          ; Rand1 = Rand2 = Rand3 = Rand4 = $D4

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Puts a random value in the RAM addresses from $81 to $F0
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    lda #0             ; A = 0
    ldx #$F0           ; X = #$F0

MemLoop:
    txa                ; since the GetRandomByte routine uses X inside it,
    pha                ; we are saving X in the stack to be restored later
    
    jsr GetRandomByte  ; call routine to load A with a random byte
    sta Random         ; save the random byte generated by the function
   
    pla                ; restore the stack value saved previously,
    tax                ; and put it back to the X register
    
    lda Random         ; load A with the random byte generated previously
    sta $0,X           ; store the random value at address $0 + X
    dex                ; X--
    cpx #$80           ; compare X with $80
    bne MemLoop        ; loop while not equal (until z-flag is set)
    
    sta $0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Subroutine to generate a random number and save it in the accumulator
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GetRandomValue subroutine
    lda Random
    asl
    eor Random
    asl
    eor Random
    asl
    asl
    eor Random
    asl
    rol Random
    rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Subrouting to generate random bit
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Rand1, Rand2, Rand3, Rand4 are RAM locations, initialized to any nonzero
;; value at program initialization
;; A random bit is generated by XORing bits 27 and 30 of the register, then
;; shifting the entire thing one bit to the left and placing the new bit on
;; the right. This algorithm produces a sequence of 2^31 - 1 random bits
;; before repeating.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GetRandomBit subroutine
    lda Rand4               ; load accumulator with the value of Rand4
    asl
    asl
    asl
    eor Rand4               ; new bit is now in bit 6 of A
    asl
    asl                     ; new bit is now in carry                               ;<<<<<<<<<<<<<
    rol Rand1               ; shift new bit to bit 0 of A, bit 7 goes to carry
    rol Rand2               ; shift old bit 7 into bit 8, etc.
    rol Rand3
    rol Rand4
    rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Subrouting to generate random byte
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Produces 8 random bits and output the result in the accumulator register A
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GetRandomByte subroutine
    ldx #8
.RandomByteLoop
    jsr GetRandomBit
    dex
    bne .RandomByteLoop
    lda Rand1
    rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Fill  ROM size to exactly 4KB
;; Also tells 6502 where our program should start (at $FFFC)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    org $FFFC          ; moves/jumps origin to ROM address $FFFC
    .word Start        ; puts 2 bytes in $FFFC with program reset address
    .word Start	       ; puts interrupt vector at $FFFE (unused in VCS)
